(ns criterium.measured
  "Implements the concept of a measured function.

  Criterium's metric collection works on a Measured instance. A measured
  implements a timed, batch invocation of the expression to be tested.
  The arguments to be passed to the function are generated by the args-fn
  function, and passed to the function invocation, so they do not get
  optimised out as constants.

  Criterium creates a measured for an arbitrary expression, but it is
  also useful to construct your own."
  (:require
   [criterium.measured.impl :as impl]))

;;; Measured type

(defn measured?
  "Predicate for x being a Measured."
  [x]
  (impl/measured? x))

(defn measured
  "Return a Measured for a function that can be benchmarked.

  The Measured is the basic unit of measurement. A Measured consists of
  an arguments generation funtion and a function to be measured.  The
  function to be measured takes the result of calling the arrguments
  function and an eval-count as arguments, ie. `(f (args-fn)
  eval-count)`, and returns an `[elapsed-time expr-value]` tuple.

  The arguments function is used to prevent constant folding for
  constant inputs.

  The eval-count allows the function to time multiple evaluations of the
  subject expression, so that we can measure expressions that are faster
  than the timer granularity.

  expr-fn, if specified, returns a symbolic representation of the measured,
  for inspection purposes (unused internally)."
  ^criterium.measured.impl.Measured
  [args-fn f & [expr-fn]]
  (impl/measured args-fn f expr-fn))

(defn args
  "Generate the state for a measured."
  [measured]
  ((:args-fn measured)))

(defn invoke
  "Invoke the given Measured.

  Calls the Measured's function with the given state and eval-count.
  The state can be created with `args`."
  [measured state eval-count]
  ((:f measured) state eval-count))

(defn ^:no-doc symbolic
  "Return a symbolic representation of the measured.
  Provides a way to introspect how the measured will be executed."
  [measured]
  (when-let [expr-fn (:expr-fn measured)]
    (expr-fn)))

;;; Build a Measured from an expression

(defmacro expr
  "Return a Measured for the given expression.

  The expression is wrapped in a function.

  When the expression is a list form, it is treated as a function call.
  The function arguments are treated as constant expressions and are
  hoisted into a state function.  The result of the state function is a
  vector that is passed to the function wrapper as a vector and
  destructured."
  ([expr]
   (impl/measured-expr* expr nil))
  ([expr options]
   (impl/measured-expr* expr options)))

#_{:clj-kondo/ignore [:clojure-lsp/unused-public-var]}
(defmacro callable
  "Return a Measured for the given no arg function."
  ([f]
   (impl/measured-callable f))
  ([sf f]
   (impl/measured-callable sf f)))
